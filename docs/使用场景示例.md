# 使用场景示例

> 真实的使用场景和对话示例

---

## 📋 目录

1. [场景 1: 项目开发助手](#场景-1-项目开发助手)
2. [场景 2: 学习笔记管理](#场景-2-学习笔记管理)
3. [场景 3: 技术决策记录](#场景-3-技术决策记录)
4. [场景 4: 代码审查助手](#场景-4-代码审查助手)
5. [场景 5: 个人知识库](#场景-5-个人知识库)

---

## 场景 1: 项目开发助手

### 背景
你正在开发一个电商网站，需要 AI 帮助你跟踪进度、记录决策、回忆历史。

### 第 1 天: 项目启动

```
你: 你好，我要开始一个新的电商项目，使用 Next.js 14 和 TypeScript

AI: (调用 initialize_session)
你好！我已经准备好了。让我记录下这个项目的技术栈。

(调用 append_daily_log)
已记录：
- 项目类型：电商网站
- 技术栈：Next.js 14 + TypeScript

(调用 append_daily_log with atomic_fact)
已保存技术约束到知识库 ✅

你: 记住，我喜欢使用 Tailwind CSS 做样式

AI: (调用 append_daily_log with category="user_preference")
明白了，已更新你的偏好设置 ✅
```

**生成的文件**:

`agent_memory/memory/2026/02_february/week_06/2026-02-05.md`:
```markdown
---
type: daily_log
date: "2026-02-05"
tags: ["project-start", "ecommerce", "nextjs"]
summary: "启动电商项目，确定技术栈"
---

### 09:00
项目启动
- 项目类型：电商网站
- 技术栈：Next.js 14 + TypeScript
- 样式方案：Tailwind CSS
```

`agent_memory/knowledge/areas/general/items.json`:
```json
[
  {
    "id": "fact-abc123",
    "fact": "电商项目使用 Next.js 14 App Router",
    "category": "domain_knowledge",
    "timestamp": "2026-02-05T09:00:00",
    "status": "active"
  }
]
```

`agent_memory/MEMORY.md`:
```markdown
---
type: implicit_knowledge
version: "1.0"
last_updated: "2026-02-05"
---
# User Profile
- 偏好: 使用 Tailwind CSS 做样式
- 角色: 全栈工程师

# Style Guidelines
- 语气: 专业、友好
```

### 第 2 天: 功能开发

```
你: 我今天要开发用户登录功能

AI: (调用 initialize_session)
早上好！昨天我们启动了电商项目，今天开始开发登录功能。

你: 对，我打算使用 NextAuth.js

AI: 好的选择！NextAuth.js 与 Next.js 14 集成得很好。

(调用 append_daily_log)
已记录今天的开发计划 ✅

---

(几小时后)

你: 我遇到了一个问题，NextAuth 的 session 在 Server Component 中获取不到

AI: 让我帮你记录这个问题。

(调用 append_daily_log)

这是一个常见问题。在 Next.js 14 的 Server Component 中，你需要使用 
`getServerSession` 而不是 `useSession`。

示例代码：
\`\`\`typescript
import { getServerSession } from "next-auth/next"
import { authOptions } from "@/app/api/auth/[...nextauth]/route"

export default async function Page() {
  const session = await getServerSession(authOptions)
  // ...
}
\`\`\`

你: 完美！解决了，帮我记录下这个解决方案

AI: (调用 append_daily_log with atomic_fact)
已保存到知识库 ✅ 下次遇到类似问题就能快速找到解决方案了。
```

### 第 7 天: 周总结

```
你: 帮我生成本周的工作总结

AI: (调用 get_period_context("week"))
好的，让我回顾一下本周的工作...

(调用 archive_period)

# 本周工作总结 (2026-02-03 至 2026-02-09)

## 主要成果
✅ 完成项目初始化和技术栈选型
✅ 实现用户认证模块 (NextAuth.js)
✅ 开发商品列表页面
✅ 集成 Stripe 支付

## 技术决策
- 使用 Next.js 14 App Router
- 采用 NextAuth.js 进行身份认证
- 使用 Prisma ORM 管理数据库
- 集成 Stripe 作为支付网关

## 遇到的问题及解决方案
1. NextAuth session 在 Server Component 中的获取
   - 解决：使用 getServerSession
2. Stripe webhook 验证失败
   - 解决：正确配置 webhook secret

## 下周计划
- 开发购物车功能
- 实现订单管理
- 添加商品搜索功能

已保存到 week_summary.md ✅
```

---

## 场景 2: 学习笔记管理

### 背景
你正在学习 React 的高级特性，希望 AI 帮你管理学习笔记。

### 学习 useTransition

```
你: 我今天学习了 React 18 的 useTransition hook

AI: 很好！这是 React 18 的重要特性。你学到了什么？

你: useTransition 可以让状态更新变成非阻塞的，用户界面不会卡顿

AI: (调用 append_daily_log with atomic_fact)
已保存到知识库 ✅

你能给我一个具体的使用场景吗？

你: 比如在搜索框输入时，可以用 useTransition 包裹搜索结果的更新，
    这样输入不会被阻塞

AI: (调用 append_daily_log)
完美的例子！已记录 ✅

让我帮你整理一下：

\`\`\`typescript
import { useState, useTransition } from 'react'

function SearchBox() {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState([])
  const [isPending, startTransition] = useTransition()

  const handleChange = (e) => {
    setQuery(e.target.value)  // 高优先级：立即更新输入框
    
    startTransition(() => {
      // 低优先级：可以被打断的搜索
      setResults(search(e.target.value))
    })
  }

  return (
    <>
      <input value={query} onChange={handleChange} />
      {isPending && <Spinner />}
      <Results data={results} />
    </>
  )
}
\`\`\`

这个例子已经保存到你的学习笔记中了。
```

### 一周后复习

```
你: 我记得我们学过 React 的并发特性，但忘记细节了

AI: (调用 query_memory_headers(tags=["react", "learning"]))
让我帮你找找...

(调用 read_memory_content)

找到了！上周你学习了 useTransition hook。这是你的笔记：

[显示之前的学习内容和代码示例]

需要我再解释一遍吗？
```

---

## 场景 3: 技术决策记录

### 背景
团队需要记录重要的技术决策和变更历史。

### 初始决策

```
你: 我们决定使用 MySQL 作为数据库

AI: (调用 append_daily_log with atomic_fact)
已记录技术决策 ✅

可以告诉我选择 MySQL 的原因吗？这样以后可以回溯决策依据。

你: 主要是因为团队熟悉 MySQL，而且现有的运维工具都是基于 MySQL 的

AI: (调用 append_daily_log)
明白了，已补充决策依据 ✅
```

### 决策变更

```
(三个月后)

你: 我们决定迁移到 PostgreSQL

AI: (调用 query_memory_headers(tags=["database"]))
我记得之前选择的是 MySQL。可以说说为什么要迁移吗？

你: 因为我们需要使用 JSON 字段和全文搜索，PostgreSQL 在这方面更强

AI: (调用 append_daily_log with atomic_fact + supersedes_id)
明白了。我已经更新了技术栈信息，并保留了之前的决策历史 ✅

现在的状态：
- 当前数据库：PostgreSQL
- 之前使用：MySQL
- 变更原因：需要 JSON 字段和全文搜索
- 变更时间：2026-05-15

需要我帮你制定迁移计划吗？
```

### 查看决策历史

```
你: 我们为什么从 MySQL 换到 PostgreSQL 来着？

AI: (调用 read_memory_content)
让我查看决策历史...

找到了！这是完整的决策链：

**初始决策 (2026-02-05)**
- 数据库：MySQL
- 原因：团队熟悉，运维工具完善

**决策变更 (2026-05-15)**
- 新数据库：PostgreSQL
- 原因：需要 JSON 字段和全文搜索功能
- PostgreSQL 在这些方面比 MySQL 更强

这个决策历史已经完整保存，随时可以查阅。
```

---

## 场景 4: 代码审查助手

### 背景
你希望 AI 记住代码审查中的常见问题和团队规范。

### 记录审查规范

```
你: 在代码审查中，我们要求所有的 API 函数都必须有错误处理

AI: (调用 append_daily_log with atomic_fact)
已保存到团队规范 ✅

你: 还有，所有的数据库查询都要使用参数化查询，防止 SQL 注入

AI: (调用 append_daily_log with atomic_fact)
重要的安全规范，已记录 ✅
```

### 应用规范

```
(审查代码时)

你: 帮我审查这段代码：
\`\`\`typescript
async function getUser(id: string) {
  const user = await db.query(`SELECT * FROM users WHERE id = ${id}`)
  return user
}
\`\`\`

AI: (调用 query_memory_headers(tags=["code-review", "security"]))
我发现了几个问题：

❌ **安全问题**：SQL 注入风险
根据我们的团队规范，所有数据库查询必须使用参数化查询。

❌ **错误处理缺失**
根据我们的规范，所有 API 函数都必须有错误处理。

建议修改：
\`\`\`typescript
async function getUser(id: string) {
  try {
    // 使用参数化查询
    const user = await db.query(
      'SELECT * FROM users WHERE id = ?',
      [id]
    )
    return user
  } catch (error) {
    console.error('Failed to get user:', error)
    throw new Error('User not found')
  }
}
\`\`\`

你: 完美！帮我记录这次审查

AI: (调用 append_daily_log)
已记录代码审查 ✅
```

---

## 场景 5: 个人知识库

### 背景
你想建立一个个人的技术知识库，随时查询。

### 积累知识

```
你: 记住，Git rebase 和 merge 的区别是：
    - rebase 会重写历史，创建线性历史
    - merge 会保留分支历史，创建合并提交

AI: (调用 append_daily_log with atomic_fact)
已保存到知识库 ✅

你: 还有，Docker 的最佳实践：
    1. 使用 .dockerignore 排除不必要的文件
    2. 多阶段构建减小镜像大小
    3. 使用特定版本的基础镜像，不要用 latest

AI: (调用 append_daily_log with atomic_fact)
Docker 最佳实践已保存 ✅
```

### 快速查询

```
(一个月后)

你: Git rebase 和 merge 有什么区别来着？

AI: (调用 search_memory_content("git rebase merge"))
找到了！这是你之前记录的：

**Git rebase vs merge**
- rebase：重写历史，创建线性历史
- merge：保留分支历史，创建合并提交

**使用建议**：
- 本地分支整理：使用 rebase
- 合并到主分支：使用 merge

你: Docker 的最佳实践呢？

AI: (调用 search_memory_content("docker best practice"))
这是你的 Docker 最佳实践笔记：

1. 使用 .dockerignore 排除不必要的文件
2. 多阶段构建减小镜像大小
3. 使用特定版本的基础镜像，不要用 latest
4. 合并 RUN 命令减少层数
5. 使用非 root 用户运行容器

需要具体的示例代码吗？
```

### 知识关联

```
你: 我在学习 Kubernetes，它和 Docker 有什么关系？

AI: (调用 query_memory_headers(tags=["docker", "devops"]))
根据你的知识库，Docker 是容器技术，而 Kubernetes 是容器编排平台。

简单来说：
- Docker：打包和运行单个容器
- Kubernetes：管理和编排多个容器

你之前记录的 Docker 最佳实践在 Kubernetes 中同样适用，
因为 Kubernetes 底层也是使用 Docker（或其他容器运行时）。

需要我帮你记录 Kubernetes 的学习笔记吗？
```

---

## 总结

这些场景展示了 Adaptive-Agent-MCP 的核心价值：

1. **持久化记忆**: 不会忘记之前的对话和决策
2. **知识积累**: 随着时间推移，知识库越来越丰富
3. **快速检索**: 可以快速找到历史信息
4. **上下文理解**: 理解项目的完整历史和背景
5. **个性化**: 记住用户的偏好和习惯

通过这个系统，AI Agent 真正成为了你的"第二大脑"！

---

**想要更多示例？查看 [使用指南](./使用指南.md)**
